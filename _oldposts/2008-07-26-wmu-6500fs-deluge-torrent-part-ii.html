--- 
name: wmu-6500fs-deluge-torrent-part-ii
layout: post
time: 2008-07-26 01:22:00 +02:00
title: WMU-6500FS - Deluge torrent (part II)
---
<h3>Overview</h3>
In <a href="http://filodej.blogspot.com/2008/07/wmu-6500fs-deluge-torrent-part-i.html">previous part</a> we have started building the deluge torrent ...
<br/>
<br/>
We ended up with a curious error, process was aborted after an exception thrown 
in <i>libtorrent::bdecode</i>. It seems that for some reason there is exception thrown and not caught which causes immediate process termination. 

<h3>Screenshot</h3>
Here is a screenshot of the remote debugging in action:
<br/>
<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_xFBIBcRhwFQ/SIh0W3rD25I/AAAAAAAABmc/W3g-ewZLw0U/s1600-h/wmu6500fs-remote-gdb2.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://1.bp.blogspot.com/_xFBIBcRhwFQ/SIh0W3rD25I/AAAAAAAABmc/W3g-ewZLw0U/s400/wmu6500fs-remote-gdb2.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5226555303813962642" /></a>
<br/>
<span class="fullpost">

<h3>Uncaught exception</h3>
When we look at the <i>strace</i> output:
<pre class="code">
...
close(11)                               = 0
write(1, "Applying preferences\n", 21Applying preferences
)  = 21
write(1, "Starting DHT...\n", 16Starting DHT...
)       = 16
open("/root/.config/deluge/dht.state", O_RDONLY) = -1 ENOENT (No such file or directory)
rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0
kill(31503, SIGABRT)                    = 0
--- SIGABRT (Aborted) @ 0 (0) ---
+++ killed by SIGABRT +++
Process 31503 detached
</pre>

Call stack at the moment of termination:
<pre class="code">
...
Program received signal SIG32, Real-time event 32.
0x4019cb64 in __rt_sigsuspend () from /lib/libc.so.0
(gdb) Quit
(gdb) where
#0  0x4019cb64 in __rt_sigsuspend () from /lib/libc.so.0
#1  0x4019cb9b in sigsuspend () from /lib/libc.so.0
#2  0x40139cf9 in __pthread_wait_for_restart_signal () from /lib/libpthread.so.0
#3  0x401396bd in pthread_create () from /lib/libpthread.so.0
#4  0x416c9f26 in boost::thread::start_thread () from /mnt/C/sys/lib//libboost_thread-gcc33-mt-1_35.so.1.35.0
#5  0x415d68c8 in disk_io_thread (this=0x821acc8, block_size=-4) at thread.hpp:151
...
</pre>

An the corresponding source file <i>src/deluge_core.cpp</i>
<pre class="code">
    boost::filesystem::path tempPath(DHT_path, empty_name_check);
    boost::filesystem::ifstream DHT_state_file(tempPath, std::ios_base::binary);
    DHT_state_file.unsetf(std::ios_base::skipws);

    entry DHT_state;
    try
    {
<b>(1)</b>     DHT_state = bdecode(std::istream_iterator&lt;char&gt;(DHT_state_file),
            std::istream_iterator&lt;char&gt;());
        M_ses-&gt;start_dht(DHT_state);
        //        printf("DHT state recovered.\r\n");

        //        // Print out the state data from the FILE (not the session!)
        //        printf("Number of DHT peers in recovered state: %ld\r\n", count_DHT_peers(DHT_state));

    }
<b>(2)</b> catch (std::exception&)
    {
        printf("No DHT file to resume\r\n");
        M_ses-&gt;start_dht();
    }
</pre>
... it seems obvious what happened. Application tried to open the <i>dht.state</i> file
and since there was no such file an exception was thrown in the <i>std::istream_iterator</i>
constructor (source code line marked as <b>(1)</b>). This exception is nevertheless not caught 
in the catch block (source code line marked as <b>(2)</b>). I do not know why, there is no aparent 
reason (the exception has definitely the <i>std::exception</i> base), the fact is that 
due to this the application is aborted.
<br/>
<h3>Uncaught exception - workaround</h3>
For now I decided to make the following workaround, explicitly handle the missing 
file and so bypass the exception:
<pre class="code">
    boost::filesystem::path tempPath(DHT_path, empty_name_check);
    boost::filesystem::ifstream DHT_state_file(tempPath, std::ios_base::binary);
    DHT_state_file.unsetf(std::ios_base::skipws);

    entry DHT_state;
    <b>if ( !exists( tempPath ) )
    {
        printf("No DHT file to resume\r\n");
        M_ses-&gt;start_dht();
    }
    else</b> try
    {
        DHT_state = bdecode(std::istream_iterator&lt;char&gt;(DHT_state_file),
            std::istream_iterator&lt;char&gt;());
        M_ses-&gt;start_dht(DHT_state);
        //        printf("DHT state recovered.\r\n");

        //        // Print out the state data from the FILE (not the session!)
        //        printf("Number of DHT peers in recovered state: %ld\r\n", count_DHT_peers(DHT_state));

    }
    catch (std::exception&)
    {
        printf("No DHT file to resume\r\n");
        M_ses-&gt;start_dht();
    }
</pre>
The unified diff looks as follows:
<pre class="code">
dev# diff -u src/deluge_core.cpp.old src/deluge_core.cpp
--- src/deluge_core.cpp.old     2008-06-04 20:03:49.000000000 -0600
+++ src/deluge_core.cpp 2008-07-02 16:32:01.000000000 -0600
@@ -1889,7 +1889,12 @@
     DHT_state_file.unsetf(std::ios_base::skipws);

     entry DHT_state;
-    try
+    if ( !exists( tempPath ) )
+    {
+        printf("No DHT file to resume\r\n");
+        M_ses-&gt;start_dht();
+    }
+    else try
     {
         DHT_state = bdecode(std::istream_iterator&lt;char&gt;(DHT_state_file),
             std::istream_iterator&lt;char&gt;());
</pre>
With this workaround we are able to sucessfully open the application. But when we 
add a torrent file, there is another (but similar) problem. Another exception is thrown 
which leads to process termination. Since the local debugging is really slow on the box,
before we proceed to solve this problem, let's look how to debug remotely.
<h3>Remote debugging</h3>
For remote debugging we will use the <i>gdbserver</i>. Following relevant inf is in the 
<a href="http://davis.lbl.gov/Manuals/GDB/gdb_17.html">GDB remote debugging manual</a>:
<blockquote><pre>
gdbserver is a control program for Unix-like systems, which allows you to connect your program 
with a remote GDB via target remote - but without linking in the usual debugging stub.
...
The `host:2345' argument means that gdbserver is to expect a TCP connection from machine `host' 
to local TCP port 2345. (Currently, the `host' part is ignored.)
...
On some targets, gdbserver can also attach to running programs. This is accomplished via the 
--attach argument.
...
On the GDB host machine, you need an unstripped copy of your program, since GDB needs symbols 
and debugging information. Start up GDB as usual, using the name of the local copy of your 
program as the first argument. ... After that, use target remote to establish communications 
with gdbserver.
</pre></blockquote>
The use of <i>gdbserver</i> is ideal for us, since due to the deployment process we have 
identical copied of the debugged program both on the <b>box#</b> and on the build 
<b>dev#</b> system.
<br/>
<br/>
So on the box we can run the <i>deluge</i>
<pre class="code">
box# deluge &
[1] 29193
</pre>
... and attach to it with the <i>gdbserver</i>:
<pre class="code">
box# gdbserver colinux:2345 --attach 29193
Attached; pid = 29193
Listening on port 2345
</pre>
or alternatively we can run the gdbserver running the <i>deluge</i> roght from the beggining:
<pre class="code">
box# gdbserver colinux:2345 `which python` `which deluge`
Process /mnt/C/sys/bin/python created; pid = 29235
Listening on port 2345
</pre>
Now we can connect to the gdbserver with gdb running on the build machine (PC).
Since the <i>deluge</i> just a python script, the executable we will debug
is in fact <i>python interpreter</i>:
<pre class="code">
dev# gdb `which python`
...
(gdb) target remote 192.168.1.104:2345
(gdb) cont
Continuing.
[New Thread 1024]
...
</pre>
Ok, that's it.
<br/>
<br/>
<i>Note:</i> sometimes, when we interrupt the debugging process, the deluge
is not properly killed, there remains an instance. When we start deluge again 
the output looks like this:
<pre class="code">
...
create proxy object
create iface
send to iface

Child exited with retcode = 0

Child exited with status 0
GDBserver exiting
</pre>
In such situation we have to find the hanging processes and kill them:
<pre class="code">
box# ps ax | grep deluge
29429 root      14136 S     1.7  /mnt/C/sys/bin/python /mnt/C/sys/bin/deluge
29440 root      14136 S     0.0  /mnt/C/sys/bin/python /mnt/C/sys/bin/deluge
29482 root        324 S     0.0  grep deluge
box# kill -9 29429 29440
</pre>

<h3>Uncaught exceptions - looking for a cause</h3>
So as I already said, the workaround pushed us forward, but another exception 
is thrown later on, when we open a torrent file:
<pre class="code">
(gdb) where
...
#81 0xbfffca60 in ?? ()
#82 0x4027140f in __cxa_call_unexpected () from /mnt/C/sys/lib//libstdc++.so.5
#83 0x4027140f in __cxa_call_unexpected () from /mnt/C/sys/lib//libstdc++.so.5
#84 0x40271439 in std::terminate () from /mnt/C/sys/lib//libstdc++.so.5
#85 0x40271560 in __cxa_throw () from /mnt/C/sys/lib//libstdc++.so.5
#86 0x414d0d39 in libtorrent::entry::operator[] (this=0x821a4e0, key=0x41644ef4 "url-list") at entry.hpp:77
#87 0x415a5bc8 in libtorrent::torrent_info::read_torrent_info (this=0xbfffd090, torrent_file=@0xbfffcee0)
    at libtorrent/src/torrent_info.cpp:519
#88 0x4159e59e in torrent_info (this=0xbfffd090, torrent_file=@0xbfffcee0) at libtorrent/src/torrent_info.cpp:236
#89 0x41629068 in internal_get_torrent_info (torrent_name=@0x6) at src/deluge_core.cpp:264
#90 0x4162d0e7 in torrent_dump_file_info (self=0x0, args=0x41a7ab2c) at stl_alloc.h:652
#91 0x4005d122 in PyCFunction_Call (func=0x4127122c, arg=0x41a7ab2c, kw=0x6) at Objects/methodobject.c:108
...
</pre>
When we look at the stack frame 87 and <i>torrent_file</i> structure:
<pre class="code">
(gdb) frame 87
#87 0x415a5bc8 in libtorrent::torrent_info::read_torrent_info (this=0xbfffd090, torrent_file=@0xbfffcee0)
    at libtorrent/src/torrent_info.cpp:519
519                             entry const& url_seeds = torrent_file["url-list"];

(gdb) list
514                     catch (type_error) {}
515
516                     // if there are any url-seeds, extract them
517                     try
518                     {
519                             entry const& url_seeds = <b>torrent_file["url-list"]</b>;
520                             if (url_seeds.type() == entry::string_t)
521                             {
522                                     m_url_seeds.push_back(url_seeds.string());
523                             }

(gdb) print torrent_file
$1 = (const libtorrent::entry &) @0xbfffcee0: {m_type = dictionary_t, {data = "øv!\b\004\000\000\000ògB@",
    dummy_aligner = 17316280056}}
</pre>
... and to the <i>src/deluge-torrent-0.5.9.3/libtorrent/src/entry.cpp</i> file :
<pre class="code">
#ifndef BOOST_NO_EXCEPTIONS
        const entry& entry::operator[](char const* key) const
        {
                dictionary_type::const_iterator i = dict().find(key);
                if (i == dict().end()) <b>throw type_error</b>(
                        (std::string("key not found: ") + key).c_str());
                return i-&gt;second;
        }

        const entry& entry::operator[](std::string const& key) const
        {
                return (*this)[key.c_str()];
        }
#endif
</pre>
... we can see that the <i>torrent_file</i> is a python-like dictionary, when one tries to access
a value stored with a key and there is no such entry, an exception is thrown. 
As in previous case neither this exception is not caught. It is time to stop with workarounds and look at the exception issue in a finer detail.
<br/>
<a href="http://www.uclibc.org/lists/uclibc/2004-May/008981.html">This discussion</a> contains an 
ellegant test for exception catching. It seems that I am not alone having this sort of problems:
<blockquote><pre>
&gt; So, the throw+catch are not hooking up properly under uClibc.
&gt; This is uClibc's problem.

What version of uClibc?  gcc?  binutils?  How did you build your
toolchain?  Was gcc built with --enable-sjlj-exceptions?  What
kernel version are you using?
...
&gt; part3:
&gt; comment on gdb #5: __cxa_throw ()
&gt; &gt;From the backtrace above it looks that somethings goes wrong during stack 
&gt; unwinding - does exception catching work for other C++ programs ?

It does if gcc was built properly...

    <a href="http://codepoet.org/throw1.cpp">http://codepoet.org/throw1.cpp</a>
    <a href="http://codepoet.org/throw2.cpp">http://codepoet.org/throw2.cpp</a>
</pre></blockquote>
So let's make the same test:
<pre class="code">
dev# cd /usr/local/src/
dev# mkdir test_exceptions
dev# cd test_exceptions/
dev# wget <a href="http://codepoet.org/throw1.cpp">http://codepoet.org/throw1.cpp</a>
dev# cat throw1.cpp
#include &lt;features.h&gt;
#include "iostream"
int main(void)
{
    try {
        throw("This is an exception");
    }
    catch (...) {
        std::cout &lt;&lt; "caught an exception\n";
    }
    return(0);
}
dev# g++ -Wall -O2 throw1.cpp -o throw1
dev# ldd throw1
        libstdc++.so.5 =&gt; /lib/libstdc++.so.5 (0xb7edf000)
        libm.so.0 =&gt; /lib/libm.so.0 (0xb7ed1000)
        libgcc_s.so.1 =&gt; /lib/libgcc_s.so.1 (0xb7ec9000)
        libc.so.0 =&gt; /lib/libc.so.0 (0xb7e35000)
        ld-uClibc.so.0 =&gt; /lib/ld-uClibc.so.0 (0xb7f91000)
dev# ./throw1
Aborted
</pre>
So even in such a trivial case the exception is not caught and process is aborted.
<br/>
Now let's look at our gcc configuration:
<pre class="code">
dev# gcc -v
Using built-in specs.
Configured with: /opt/buildroot/toolchain_build_i386/gcc-3.3.6/configure --prefix=/usr --build=i386-pc-linux-gnu --host=i386-linux-uclibc 
--target=i386-linux-uclibc --enable-languages=c,c++,objc --enable-shared --with-gxx-include-dir=/usr/include/c++ --disable-__cxa_atexit 
--enable-target-optspace --with-gnu-ld --disable-nls --enable-multilib : 
(reconfigured) /opt/buildroot/toolchain_build_i386/gcc-3.3.6/configure --prefix=/usr --build=i386-pc-linux-gnu --host=i386-linux-uclibc 
--target=i386-linux-uclibc --enable-languages=c,c++,objc --enable-shared --with-gxx-include-dir=/usr/include/c++ --disable-__cxa_atexit 
--enable-target-optspace --with-gnu-ld --disable-nls --enable-multilib : 
(reconfigured) /home/joker/CR/opt/buildroot/toolchain_build_i386/gcc-3.3.6/configure --prefix=/usr --build=i386-pc-linux-gnu 
--host=i386-linux-uclibc --target=i386-linux-uclibc --enable-languages=c,c++,objc --enable-shared --with-gxx-include-dir=/usr/include/c++ 
--disable-__cxa_atexit --enable-target-optspace --with-gnu-ld --disable-nls --enable-multilib
Thread model: posix
gcc version 3.3.6
</pre>
... it seems that it is not configured with <i>--enable-sjlj-exceptions</i>.
<br/>
<a name="gcc-compatibility-issue"></a>
This message named <a href="http://lists.debian.org/debian-gcc/2004/02/msg00096.html">
"libgcc_s.so compatibility between 3.3 and 3.4 (sjlj/dwarf2 exceptions)"</a> describes a problem with the change of default exception model. It seems that the gcc change management (so versioning) 
did not go very well at that point:
<blockquote>
On m68k-linux and parisc-linux between 3.3 and 3.4 the default
exception model changed from sjlj based exceptions to dw2 based
exceptions. Unfortunately at this time the soversion number of the
shared libgcc was not bumped.
...
I didn't look at other architectures, if the distinction is needed as
well.
</blockquote>
Regarding to <a href="http://www.uclibc.org/lists/uclibc/2005-June/011851.html">this message</a>
it seems that re-build of GCC with <i>--enable-sjlj-exceptions</i> could be a solution. The problem 
is that I have not prepared the uClibc build environment (I just used 
<a href="http://mgb111.pradnik.net/addons/uclibc-basic.tar.bz2">the one</a> prebuilt by JoKeR) and
so have no experience with building the GCC. 
<br/>
I did not want to start such a big task, so I decided to give another shot to a workaround:
<h3>Disable exceptions</h3>
The code in the <i>src/deluge-torrent-0.5.9.3/libtorrent/src/entry.cpp</i> file inspired me to this workaround:
<pre class="code">
#ifndef BOOST_NO_EXCEPTIONS
        const entry& entry::operator[](char const* key) const
        {
                dictionary_type::const_iterator i = dict().find(key);
                if (i == dict().end()) throw type_error(
                        (std::string("key not found: ") + key).c_str());
                return i-&gt;second;
        }

        const entry& entry::operator[](std::string const& key) const
        {
                return (*this)[key.c_str()];
        }
#endif
</pre>
It seems that the <i>libtorrent</i> code is prepared for cases when there is no exception support in the platform (as is the case for some embedded systems for example). So why not try to disable the boost exceptions?
<pre class="code">
dev# cd /usr/local/src/boost_1_35_0
dev# nano boost/config/user.hpp
</pre>
append the following at the end of the file:
<pre class="code">
#define BOOST_NO_EXCEPTIONS
</pre>
... and now re-build the boost libraries:
<pre class="code">
dev# make
...
libs/serialization/src/xml_woarchive.cpp:58:   instantiated from here
boost/archive/iterators/wchar_from_mb.hpp:119: error: `dataflow_exception'
   undeclared in namespace `boost::archive::iterators'
...
...failed updating 9 targets...
...skipped 2 targets...
Not all Boost libraries built properly.
</pre>
It seems not all the libraries are compatible with this define, anyway, let's 
proceed (finish the <i>boost</i> installation and restart the <i>deluge</i> build process):
<pre class="code">
dev# make install
...
dev# cd ../deluge-torrent-0.5.9.3
dev#  python setup.py clean
dev# python setup.py build
...
libtorrent/src/metadata_transfer.cpp: In member function `virtual bool
   libtorrent::&lt;unnamed&gt;::metadata_peer_plugin::on_extension_handshake(const
   libtorrent::entry&)':
libtorrent/src/metadata_transfer.cpp:275: error: passing `const
   libtorrent::entry' as `this' argument of `libtorrent::entry&
   libtorrent::entry::operator[](const char*)' discards qualifiers
error: command 'gcc' failed with exit status 1
</pre>
In <i>libtorrent/src/metadata_transfer.cpp</i> there is a following code:
<pre class="code">
    virtual bool on_extension_handshake(entry const& h)
    {
            <b>entry const& messages = h["m"];</b>
            if (entry const* index = messages.find_key("LT_metadata"))
            {
                    m_message_index = int(index-&gt;integer());
                    return true;
            }
            else
            {
                    m_message_index = 0;
                    return false;
            }
    }
</pre>
... in <i>libtorrent/include/libtorrent/entry.hpp</i> there are following map accessors:
<pre class="code">
                entry& operator[](char const* key);
                entry& operator[](std::string const& key);
#ifndef BOOST_NO_EXCEPTIONS
                const entry& operator[](char const* key) const;
                const entry& operator[](std::string const& key) const;
#endif
                entry* find_key(char const* key);
                entry const* find_key(char const* key) const;
                entry* find_key(std::string const& key);
</pre>
the solution was to change the <i>operator[]</i> access to <i>find_key()</i> method call:
<pre class="code">
    virtual bool on_extension_handshake(entry const& h)
    {
<b>//          entry const& messages = h["m"];
            entry const* messages( h.find_key("m") );
            if ( messages )
            {</b>
                if (entry const* index = messages-&gt;find_key("LT_metadata"))
                {
                    m_message_index = int(index-&gt;integer());
                    return true;
                }
            }
<b>//          else</b>
            {
                    m_message_index = 0;
                    return false;
            }
    }
</pre>
There is a lot of such places in the code, it seems that the library support 
for <i>BOOST_NO_EXCEPTIONS</i> directive is not fully implemented yet:
<pre class="code">
dev# python setup.py build
...
libtorrent/src/ut_pex.cpp: In member function `virtual bool
   libtorrent::&lt;unnamed&gt;::ut_pex_peer_plugin::on_extension_handshake(const
   libtorrent::entry&)':
libtorrent/src/ut_pex.cpp:201: error: passing `const libtorrent::entry' as
   `this' argument of `libtorrent::entry& libtorrent::entry::operator[](const
   char*)' discards qualifiers
error: command 'gcc' failed with exit status 1
</pre>
I still did not feel ready to rebuild the GCC. In a desperation I looked to the 
<a href="http://deluge-torrent.org/">deluge site</a> and noticed that there is a 
new version out there - 1.0.0_RC3. It promised a change in my miserable situation.
<br/>
<h3>Deluge new version - Disable exceptions</h3>
So let's upgrade:
<pre class="code">
dev# cd /usr/local/src/
dev# wget <a href="http://download.deluge-torrent.org/source/0.9.03/deluge-0.9.03.tar.gz">http://download.deluge-torrent.org/source/0.9.03/deluge-0.9.03.tar.gz</a>
dev# tar xzvf deluge-0.9.03.tar.gz
dev# cd deluge-0.9.03
dev# python setup.py build
...
In file included from /mnt/C/sys/include/boost-1_35/boost/thread.hpp:17,
                 from libtorrent/include/libtorrent/storage.hpp:44,
                 from libtorrent/include/libtorrent/peer_connection.hpp:63,
                 from libtorrent/src/peer_connection.cpp:41:
/mnt/C/sys/include/boost-1_35/boost/thread/recursive_mutex.hpp:18:2: #error "Boost threads unavailable on this platform"
...
</pre>
We already have a solution for this:
<pre class="code">
dev# export CFLAGS="-pthread $CFLAGS "
</pre>
Then there is another build error:
<pre class="code">
dev# python setup.py build
...
libtorrent/src/torrent_handle.cpp: In member function `const
   libtorrent::torrent_info& libtorrent::torrent_handle::get_torrent_info()
   const':
libtorrent/src/torrent_handle.cpp:503: error: no matching function for call to
   `libtorrent::torrent_info::torrent_info()'
libtorrent/include/libtorrent/torrent_info.hpp:86: error: candidates are:
   libtorrent::torrent_info::torrent_info(const libtorrent::torrent_info&)
libtorrent/include/libtorrent/torrent_info.hpp:130: error:
   libtorrent::torrent_info::torrent_info(const libtorrent::entry&)
libtorrent/include/libtorrent/torrent_info.hpp:92: error:
   libtorrent::torrent_info::torrent_info(const boost::filesystem::path&)
libtorrent/include/libtorrent/torrent_info.hpp:91: error:
   libtorrent::torrent_info::torrent_info(const char*, int)
libtorrent/include/libtorrent/torrent_info.hpp:90: error:
   libtorrent::torrent_info::torrent_info(const libtorrent::lazy_entry&)
libtorrent/include/libtorrent/torrent_info.hpp:89: error:
   libtorrent::torrent_info::torrent_info(const libtorrent::sha1_hash&)
libtorrent/src/torrent_handle.cpp: In member function `libtorrent::entry
   libtorrent::torrent_handle::write_resume_data() const':
libtorrent/src/torrent_handle.cpp:533: error: return-statement with no value,
   in function declared with a non-void return type
error: command 'gcc' failed with exit status 1
</pre>
When we look at <i>libtorrent/src/torrent_handle.cpp</i>:
<pre class="code">
        torrent_info const& torrent_handle::get_torrent_info() const
        {
                INVARIANT_CHECK;
#ifdef BOOST_NO_EXCEPTIONS
                <b>const static torrent_info empty;</b>
#endif
                boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
        ...
</pre>
... it is obvious that there the <i>torrent_info</i> has no default constructor,
but in case of defined <i>BOOST_NO_EXCEPTIONS</i> such one is used. 
So I tried to add one:<br/>
<i>libtorrent/include/libtorrent/torrent_info.hpp</i>:
<pre class="code">
<b>#ifdef BOOST_NO_EXCEPTIONS
 torrent_info();
#endif</b>
    torrent_info(sha1_hash const& info_hash);
    torrent_info(lazy_entry const& torrent_file);
    torrent_info(char const* buffer, int size);
    torrent_info(fs::path const& filename);
    ~torrent_info();
</pre>
<i>libtorrent/src/torrent_info.cpp</i>:
<pre class="code">
#ifdef BOOST_NO_EXCEPTIONS
        torrent_info::torrent_info()
                : m_creation_date(pt::second_clock::universal_time())
                , m_multifile(false)
                , m_private(false)
                , m_info_section_size(0)
                , m_piece_hashes(0)
        {}
#endif
</pre>
Another build error and solution was following:
<pre class="code">
dev# python setup.py build
...
libtorrent/src/torrent_handle.cpp: In member function `libtorrent::entry
   libtorrent::torrent_handle::write_resume_data() const':
libtorrent/src/torrent_handle.cpp:533: error: return-statement with no value,
   in function declared with a non-void return type
error: command 'gcc' failed with exit status 1
</pre>
Let's look to the <i>libtorrent/src/torrent_handle.cpp</i> file:
<pre class="code">
        entry torrent_handle::write_resume_data() const
        {
                INVARIANT_CHECK;

                entry ret(entry::dictionary_t);
                <b>TORRENT_FORWARD(write_resume_data(ret));</b>
                t-&gt;filesystem().write_resume_data(ret);

                return ret;
        }
</pre>
When we look at the definition of the macro in the same file:
<pre class="code">
#ifdef BOOST_NO_EXCEPTIONS

#define TORRENT_FORWARD(call) \
        boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock(); \
        if (!t) <b>return;</b> \
        session_impl::mutex_t::scoped_lock l(t-&gt;session().m_mutex); \
        t-&gt;call
...
#else

#define TORRENT_FORWARD(call) \
        boost::shared_ptr&lt;torrent&gt; t = m_torrent.lock(); \
        if (!t) throw_invalid_handle(); \
        session_impl::mutex_t::scoped_lock l(t-&gt;session().m_mutex); \
        t-&gt;call
...
</pre>
... we see that this version of macro can be used only in function returning <i>void</i>.
The solution is use another variant of the macro:
<pre class="code">
        TORRENT_FORWARD_RETURN2(write_resume_data(ret), entry() );
</pre>
Let's proceed:
<pre class="code">
dev# python setup.py build
...
libtorrent/src/memdebug.cpp:34:22: execinfo.h: No such file or directory
libtorrent/src/memdebug.cpp: In constructor `memdebug::memdebug()':
libtorrent/src/memdebug.cpp:61: error: `__malloc_hook' undeclared (first use
   this function)
libtorrent/src/memdebug.cpp:61: error: (Each undeclared identifier is reported
   only once for each function it appears in.)
libtorrent/src/memdebug.cpp:62: error: `__free_hook' undeclared (first use this
   function)
libtorrent/src/memdebug.cpp: In static member function `static void*
   memdebug::my_malloc_hook(unsigned int, const void*)':
libtorrent/src/memdebug.cpp:133: error: `backtrace' undeclared (first use this
   function)
libtorrent/src/memdebug.cpp:144: error: `backtrace_symbols' undeclared (first
   use this function)
error: command 'gcc' failed with exit status 1
</pre>
This kind of error is not connected with <i>BOOST_NO_EXCEPTIONS</i>. It is due to
the missing <i>backtrace</i> support in uClibc.
<br/>
Fortunately it seems that the <i>memdebug.cpp</i> is used just for memory debugging
(prevention of memory leaks and so), this file is self contained and there are no 
outside dependencies on this file. Let's try simply disable it (simply undefine or 
clear the file content):
<pre class="code">
<b>#if 0</b>
#if defined __linux__ && defined __GNUC__
...
#endif
<b>#endif</b>
</pre>
Here is another <i>BOOST_NO_EXCEPTIONS</i> related build error:
<pre class="code">
dev# python setup.py build
...
libtorrent/src/http_connection.cpp:208:   instantiated from here
libtorrent/include/libtorrent/variant_stream.hpp:226: error: no matching
   function for call to `libtorrent::ssl_stream&lt;libtorrent::socket_type&gt;::close
   ()'
libtorrent/include/libtorrent/ssl_stream.hpp:158: error: candidates are: void
   libtorrent::ssl_stream&lt;Stream&gt;::close(boost::system::error_code&) [with
   Stream = libtorrent::socket_type]
error: command 'gcc' failed with exit status 1
</pre>
As we see in the <i>libtorrent/include/libtorrent/ssl_stream.hpp</i> the <i>ssl_stream</i>
class contains two overloads of <i>close()</i> method, the non-parametric one disabled in case 
there are no exceptions:
<pre class="code">
#ifndef BOOST_NO_EXCEPTIONS
        void close()
        {
                m_sock.next_layer().close();
        }
#endif

        void close(error_code& ec)
        {
                m_sock.next_layer().close(ec);
        }
</pre>
In <i>libtorrent/include/libtorrent/variant_stream.hpp</i> there are two kinds of 
close visitor class: <i>close_visitor</i> (one used with exceptions) and <i>close_visitor</i>
(one used with error codes), but the "exception" variant is not disabled, let's try to fix it:
<pre class="code">
 struct close_visitor_ec
    : boost::static_visitor&lt;&gt;
  {
      close_visitor_ec(error_code& ec_)
        : ec(ec_)
      {}

      template &lt;class T&gt;
      void operator()(T* p) const
      { p-&gt;close(ec); }

      void operator()(boost::blank) const {}

      error_code& ec;
  };

<b>#ifndef BOOST_NO_EXCEPTIONS</b>
  struct close_visitor
    : boost::static_visitor&lt;&gt;
  {
      template &lt;class T&gt;
      void operator()(T* p) const
      { p-&gt;close(); }

      void operator()(boost::blank) const {}
  };
<b>#endif</b>
</pre>
When we try to rebuild, we can see the place where the inappropriate visitor is called:
<pre class="code">
dev# python setup.py build
...
libtorrent/include/libtorrent/variant_stream.hpp:665: error: `close_visitor'
   undeclared in namespace `libtorrent::aux'
error: command 'gcc' failed with exit status 1
</pre>
We have to somewhat fix the <i>libtorrent/include/libtorrent/variant_stream.hpp</i>.
There are basically two possibilities: <i>(a)</i> undefine the non-parametric version or 
<i>(b)</i>(maybe less correctly) use the error code variant and drop the error_code.<br/>
... as a quick fix I decided to use the latter method:
<pre class="code">
    void close(error_code& ec)
    {
        if (!instantiated()) return;
        boost::apply_visitor(
            aux::close_visitor_ec(ec), m_variant
        );
    }

<b>// #ifndef BOOST_NO_EXCEPTIONS   // (1st - more correct - method)</b>
    void close()
    {<i>
//        if (!instantiated()) return;
//        boost::apply_visitor(aux::close_visitor(), m_variant);</i>
<b>        error_code ec;              // 2nd - simpler - method
        close( ec );</b>
    }
<b>// #endif                        // (1st - more correct - method) </b>
</pre>
Another build problem (with already known solution) followed - undeclared 
<i>IPV6_V6ONLY</i>; so I have modified the <i>libtorrent/include/libtorrent/socket.hpp</i> 
and added the dummy <i>IPV6_V6ONLY</i> definition.
<br/>
<br/>
Then there was a bunch of errors with dictionary and lack of non-mutable <i>operator[]</i> access in case of <i>BOOST_NO_EXCEPTIONS</i> (similar to the previous version). I decided to solve it with a helper function called <i>get_subentry_const</i> implementing the missing functionality:
<br/>
The <i>libtorrent/src/kademlia/dht_tracker.cpp</i> file:
<pre class="code">
        libtorrent::entry const& get_subentry_const( libtorrent::entry const& e, char const* key )
        {
#ifndef BOOST_NO_EXCEPTIONS
            return e[key];
#else
            libtorrent::entry const* const s( e.find_key( key ) );
            if (!s) throw std::runtime_error("subentry not found");
            return *s;
#endif
        }
</pre>
This function - in case of missing key - throws the exception - which in turn cause the process 
termination, the question is whether the missing key in client code is really exceptional
or it is used in normal program flow... Alternative would be to return reference to a global 
empty instance of <i>entry</i> class.
<br/>
<br/>
Now the client code has to be modified as follows:
<pre class="code">
<i>//     std::string const& id = r["id"].string();</i>
<b>       std::string const& id = get_subentry_const( r, "id" ).string();</b>
</pre>
With all these changes the compilation completed succesfully but I got the 
following link errors:
<pre class="code">
dev# python setup.py build
...
`.L7753' referenced in section `.rodata' of build/temp.linux-i686-2.5/./libtorrent/src/create_torrent.o: defined in d
iscarded section `.gnu.linkonce.t._ZN5boost9date_time23gregorian_calendar_baseINS0_19year_month_day_baseINS_9gregoria
n9greg_yearENS3_10greg_monthENS3_8greg_dayEEEmE16end_of_month_dayES4_S5_' of build/temp.linux-i686-2.5/./libtorrent/s
rc/create_torrent.o
`.L7740' referenced in section `.rodata' of build/temp.linux-i686-2.5/./libtorrent/src/create_torrent.o: defined in d
iscarded section `.gnu.linkonce.t._ZN5boost9date_time23gregorian_calendar_baseINS0_19year_month_day_baseINS_9gregoria
n9greg_yearENS3_10greg_monthENS3_8greg_dayEEEmE16end_of_month_dayES4_S5_' of build/temp.linux-i686-2.5/./libtorrent/s
rc/create_torrent.o
...
collect2: ld returned 1 exit status
error: command 'gcc' failed with exit status 1
</pre>
As you can see in this <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=16625">bug report</a>
it seems as a known compiler bug. 
<br/>
There was one promising hint in this discussion:
<blockquote><pre>
While trying to build some C++ code with g++-3.3.6 we encountered error
messages  similar to those mentioned in earlier comments in this discussion:

  `xxx' referenced in section `.rodata' of somefile.o: defined 
  in discarded section `.gnu.linkonce.t._zzz' of something.o

  ...

We were able to eliminate these error messages and successfuly compile our code
with g++-3.3.6 by using the '-frepo' option in our g++ compiles.

I understand that this may not be the ultimate solution to the bug(s) being
discussed here, but since we ended up here when searching for this particular
error message, I'm adding this comment in case it helps other people.
</pre></blockquote>
Nevertheless when I tried the suggested workaround:
<pre class="code">
dev# export CFLAGS="$CFLAGS -frepo"
</pre>
... the result was exactly the same.
<br/>
<br/>
As you could see, I tried really hard to avoid the re-configuration and 
re-compilation of the compiler but at the end it seems inevitable.
<br/>
But it is enough for now, I feel really tired ;-)<br/>
We shall look at that in the <a href="http://filodej.blogspot.com/2008/08/wmu-6500fs-deluge-torrent-part-iii.html">next part</a>.
<br/>
<br/>
<i>Note: </i> I have created a <a href="http://code.rasterbar.com/libtorrent/ticket/377">ticket on libtorrent Trac</a>; it contains the diff with all the changes I have done. 
</span><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/183431720687819497-36517898141051356?l=filodej.blogspot.com' alt='' /></div>
